# md使用相关知识
1. 用 # 符号的组合创建不同格式标题
2. 脚注的格式：[^要注明的文本] 
3. 列表
    + 无序列表：用 * + - 加文本（符号后需加一个空格）
    + 有序列表：用数字加 . 表示
    + 列表嵌套：前面添加4个空格
4. 区块用>表示  >
     >嵌套方式与列表类似
5. 代码
    - 一个段落上的代码片段可以用反引号包起来,如`printf()` 函数
    - 代码区块使用4个空格或一个Tab键
    - 也可以用 ```包裹一段代码，并指定一种语言，如
      ```javascript
      $(document).ready(function () {
         alert('RUNOOB');
      });
---
# 用js创建动态表格
  分别用几种不同的方法，利用html和js创建动态表格，创建行、列元素，利用id读取表格内容，利用for循环改变表格大小，并实现删除指定行、列功能。

---
# JavaScript学习
* 作用域：程序中存储变量的规则，以后可以方便地找到这些变量。
* js为编译语言，传统编译语言在源代码执行之前经历的步骤：
    1. 分词
     `var a =2;` 词法单元：var、a、=、2
    2. 解析
     将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树：抽象语法树（AST）。
     上述代码可能有一个叫做Var的顶级节点，接下来是一个叫做Identifier [^标识符^]（它的值是a）的子节点，以及一个叫做AssignmentExpression的子节点，其有一个叫做Numericliteral（它的值是2）的子节点。
    3. 代码生成
     将AST转换为可执行代码的过程。
* LHS RHS查询
    - LHS：查找的目的是对变量进行赋值
    - RHS：查找的目的是获取变量的值
* 作用域可以嵌套，相当于局部变量和全局变量。
* 不成功的RHS会抛出ReferenceError[^引用错误]异常；
  不成功的LHS会自动创建一个全局变量。
* 全局变量: window.a
* 外部作用域无法访问包装函数内部的任何内容。
* 立即执行函数表达式（IIFE)：函数被包含在一对括号（）内部，成为了一个表达式，通过在末尾加上另外一个（）可以立即执行这个函数。
   ```
   (function (){
      var a=3
      console.log(a+3)
   })()
为匿名函数自调用，1.隐藏实现，1.不会污染外部（全局）命名空间,3.用它来编写js模块。
* for循环中let和var的区别
相同代码，分别用let和var声明变量,得到的结果不同
```
//使用var声明，得到3个3
var a = [];
for (var i = 0; i < 3; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); //3
a[1](); //3
a[2](); //3
//使用let声明，得到0,1,2
var a = [];
for (let i = 0; i < 3; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); //0
a[1](); //1
a[2](); //2
```
理解：对于一个for循环，设置循环变量（`var i = 0`）的地方是一个父作用域，循环体的执行代码在子作用域内。
```
{
  //我是父作用域
  var i = 0;
  if (0 < 3) {
    a[0] = function () {
      //我是子作用域
      console.log(i);
    };
  };
  i++; //为1
  if (1 < 3) {
    a[1] = function () {
      console.log(i);
    };
  };
  i++; //为2
  if (2 < 3) {
    a[2] = function () {
      console.log(i);
    };
  };
  i++; //为3
  // 跳出循环
}
//调用N次指向都是最终的3
a[0](); //3
a[1](); //3
a[2](); //3
```
[详细解析]（https://www.cnblogs.com/echolun/p/10584703.html）
* js代码执行并不是从上到下一行一行执行的，先有声明后有赋值；且只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。
* 闭包问题
    - js作用域环境中访问变量的权利是由内向外的，内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的，那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？闭包就是用来解决这一需求的，闭包的本质就是在一个函数内部创建另一个函数；、
    - 调用一次函数，产生新的内存空间，用完即删；若再次被外部使用，则被保留；
    - `var`无块级作用域，定义即为全局；`{...}`
    `let` `const`有块级作用域；
    - 在定时器、事件监听器、Ajax请求、跨窗口通信等任务中，只要使用了回调函数，实际上就是在使用闭包。
* 模块，模拟类的概念
    - 必须有外部的封闭函数，且至少被调用一次（每次调用都会创建一个新的模块实例）；
    - 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 

    